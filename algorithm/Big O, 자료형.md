# 빅오, 자료형
-   알고리즘의 실행 시간(시간 복잡도)과 함께 공간 요구사항(공간 복잡도)이 어떻게 증가하는지를 분류하는데 사용됨
-   알고리즘의 효율성을 분석하는 데에도 매우 유용하게 활용됨
-   빅오(Big-O)
    - 입력값이 무한대로 향할 때 함수의 상한을 설명하는 수학적 표기 방법
    - 주어진 (최선/최악/평균) 경우의 수행시간의 상한을 나타냄
    - 점진적 실행 시간(Asymptotic Running Time)을 표기할 때 가장 널리 쓰이는 수학적 표기법 중 하나
    - 점진적 실행 시간 = 시간 복잡도(Time Complexity)
        -   어떤 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도
        -   $4n^2+3n+4 = O(n^2)$
    - 종류
        -   $O(1)$
            - 입력값이 아무리 커도 실행시간은 일정
            - 최고의 알고리즘
            - 그런 경우가 잘 없음
            - ex) 해시테이블의 조회 및 삽입
        -   $O(log(n))$
            - 실행 시간은 입력값에 영향을 받기 시작함
	        - 매우 큰 입력값에도 크게 영향을 받지 않는 편
            - 매우 견고한 알고리즘인 편
            -   ex) 이진 검색
        -   $O(n)$
            - 입력값만큼 실행시간에 영향을 받음
            - = 선형시간 알고리즘(=Linear Time algorithm)
            - 알고리즘 수행시간이 입력값에 비례함
            - ex) 정렬되지 않은 리스트에서 최댓값 또는 최솟값
        -   $O(n*log(n))$
            - 적어도 모든 수에 대해 한번 이상은 비교해야 하는 비교 기반 정렬 알고리즘은 아무리 좋은 알고리즘도 $O(n*log(n))$ 보다 빠를 수 없음
            - 입력값이 최선인 경우, 비교를 건너뛰어 $O(n)$ 이 될 수도 있음
	            - ex) 팀소트(Timsort)
			- ex) 병합정렬
		- $O(n^2)$
			- 버블 정렬같은 비효율적인 정렬 알고리즘
		- $O(2^n)$
			- $2^n$ 보다 훨씬 오래 걸리는 알고리즘
			- 피보나치수를 재귀로 계산하는 알고리즘
		- $O(n!)$
			- 가장 느린 알고리즘
			- 입력값이 조금만 커도 웬만한 다항시간 내에는 계산이 어려움
			- ex) 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 외판원 문제(Travelling Salesman Problem = TSP)를 브루트 포스로 풀이할 때 해당함
	- 공간 복잡도를 나타낼 때도 사용함
	- 알고리즘은 흔히 "시간과 공간의 트레이드오프(Space-Time tradeoff)" 관계임
		- 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 차지하는 알고리즘은 실행 시간이 느림
- 상한과 최악
	- big O는 상한(upper bound)를 나타냄
	- 하한은?
		- $\Omega$, $\Theta$ 로 나타냄
	- 상한과 최악을 혼동하지 않아야 함
		- 빅오 표기법은 정확하게 쓰기에는 너무 길고 복잡한 함수를 '적당히 정확하게' 표현하려는 방법이기 때문에 최악의 경우/평균적인 경우의 시간 복잡도와는 아무런 계 없는 개념
		- ex) 퀵 정렬을 이용할 경우 [1,4,3,7,8,6,5]인 경우 최선으로 18번만 비교하면 되지만, [1,2,3,4,5,6,7]인 경우 최악으로 48번 계산해야 함
- 분할 상환 분석(Amortized Analysis)
	- 시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때, 알고리즘 전체를 지 않고 최악의 경우만을 살펴보는 것은 비관적이라는 이유로 분할 상환 분석 방이 등장하는 계기가 됨
	- 빅오와 함께 함수의 동작을 설명할 때 중요한 분석 방법중 하나
	- 어쩌다 한 번 뿐인일로 복잡도가 높아지는 경우는 정확하지 않다는 방법
	- 최악의 경우를 여러번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도를 계산하는 방법
	- ex) 동적 배열
		- 더블링이 일어나는 경우는 어쩌다 한번뿐이지만 이런 경우로 인해 시간 복잡도는 $O(n)$이 됨
		- 분할 상환을 하게 되면 동적 배열 삽입시 시간 복잡도는 $O(1)$이 됨
- 병렬화
	- 딥러닝의 인기로 병렬화가 가능한지 여부가 알고리즘의 우수성을 평가하는 중요한 척도중의 하나가 됨

## 파이썬 자료형
![[Pasted image 20220919174133.png]]
- 파이썬은 C나 자바처럼 성능에 대한 우선순위가 높은 언어가 아님
- 편리한 기능 제공에 우선순위를 둔 언어인 만큼 느린 속도와 더 많은 메모리를 차지하더라도 다한 기능을 제공하는데 관심을 둠
	- ex) bool의 원시 타입(primitive type)은 1비트이지만 객체인 Boolean은 128비트 차지함
	- 공간을 희생하고 편리한 기능을 제공하기 위함
- 파이썬은 __<i>모든 것이 객체</i>__
### 객체
- 불변 객체와 가변 객체로 나뉨
|클래스|설명|불변객체|
|------|---|---|
|bool|부울|o|
|int|정수|o|
|float|실수|o|
|list|리스트|x|
|tuple|튜플|o|
|str|문자|o|
|set|중복된 값을 갖지 않는 집합 자료형|x|
|dict|딕셔너리|x|
### 숫자
- int만 제공
	- 커지면 자동으로 long타입으로 변환됨
- bool은 엄밀히 따지면 논리 자료형이지만, 파이썬에서는 내부적으로 1과 0으로 처리되는 int의 브 클래스임
- object > int > bool
- 임의 정밀도란?
	- 무제한 자릿수를 제공하는 정수형
	- 어떻게 가능한가?
		- 정소를 숫자의 배열로 간주하면 가능
	- 계산속도가 저하됨
	- 하지만 숫자를 단일형으로 처리할 수 있으므로 언어를 매우 단순한 구조로 들 수 있을 뿐만 아니라, 언어를 사용하는 입장에서도 더이상 오버플로우를 걱정할 필요가 없어 잘못된 계산 오류를 방지할 수 있음
### 매핑
- 키와 자료형으로 구성된 복합 자료형
- 파이썬에서 제공하는 것은 dictionary
### 집합
- 중복된 값을 갖지 않는 자료형
- set
### 시퀀스
- =수열
- 배열이 없는 파이썬에서는 list라는 시퀀스 타입이 사실상 배열의 역할을 수행함
- 시퀀스는 불변/가변으로 나뉘게 됨
- str은 불변
	- 다음 예제에서 보면 메모리에 있는 값을 변경하는 것이 아니라 메모리 주소를 참고하는 것이 바뀜
	- 가변 객체라면 변경이 가능해야하지만 str은 불가능
```python
a = 'abc'
id('abc')
# 4317530408
id(a)
# 4317530408
a = 'def'
id('def')
# 4318831648
id(a)
# 4318831648

a[1]='d'
# Traceback (most recent call last):

## 추가정보

# is는 id()값을 비교하는 함수임
a = [1,2,3]
a == a
# True
a == list(a)
# True
a is a
# True
a is list(a)
# False

a = [1,2,3]
a == copy.deepcopy(a)
# True
a is copy.deepcopy(a)
# False

```
#### list
- 리스트 주요 연산 시간 복잡도
|연산|시간복잡도|설명|
|--|--|--|
|len(a)|$O(1)$|전체 요소의 개수를 리턴한다|
|a[i]|$O(1)$|인덱스 i의 요소를 가져온다|
|a[i:j]|$O(k)$|i부터 j까지 슬라이스의 길이만큼인 k개의 요소를 가져옴. 이 경우 객체 k에 대한 조회가 필요하므로 O(k)|
|elem in a|$O(n)$|elem 요소가 존재하는지 확인한다. 처음부터 순차 검색하므로 n만큼 시간 소요|
|a.count(elem)|$O(n)$|elem 요소의 개수를 리턴|
|a.index(elem)|$O(n)$|elem 요소의 인덱스를 리턴|
|a.append(elem)|$O(1)$|리스트 마지막에 elem 요소를 추가|
|a.pop()|$O(1)$|리스트 마지막 요소를 추출. 스택 연산|
|a.pop(0)|$O(n)$|리스트 첫번째 요소를 추출. 큐 연산. 이 경우 전체 복사가 필요하므로 O(n)이다. 큐연산을 주로 사용한다면 리스트보다는 O(1)에 가능한 deque를 권장|
|del a[i]|$O(n)$|i에 따라 다르다. 최악의 경우 O(n)이다|
|a.sort()|$O(nlogn)$|정렬. 팀소트를 사용하며, 최선의 경우 O(n)에도 실행될 수 있음|
|min(a), max(a)|$O(n)$|최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 함|
|a.reverse()|$O(n)$|뒤집는다. 리스트는 입력 순서가 유지되므로 뒤집게 되면 입력 순서가 반대로 됨|

#### dict
- 인덱스를 숫자로만 지정하는 리스트와 달리 문자를 포함해 다양한 타입을 키로 활용할 수 있음
	- 해시할 수 있다면 숫자, 문자, 집합까지 불변 객체를 모두 키로 사용할 수 있음
- 해시 테이블은 다양한 타입을 키로 지원하면서도 입력과 조회 모두 O(1)에 가능함
	- 최악의 경우 O(n)이 될 수 있으나 대부분의 경우 훨씬 더 빨리 실행 됨
	- 분할 상환 분석에 따른 시간 복잡도는 $O(1)$
- 딕셔너리 주요 연산 시간 복잡도
|연산|시간 복잡도|설명|
|--|--|--|
|len(a)|$O(1)$|요소 개수를 리턴|
|a[key]|$O(1)$|키를 조회하여 값을 리턴|
|a[key]=value|O(1)|키/값을 삽입|
|key in a|$O(1)|딕셔너리에 키가 존재하는지 확인|
- 리스트만큼 빈번하게 사용되는 자료형
- 원래 해시 테이블을 이용한 자료형은 순서가 유지되지 않아 collections.OrderedDict()라는 별도의 자료형을 사용해야 했지만, 3.7 버전부터는 내부적으로 인덱스를 이용해 입력 순서를 유지하록 개선함
	- 코딩테스트에서는 입력 순서가 유지될거라 기대말아야 함
- 딕셔너리를 효율적으로 생성하기 위한 추가 모듈
	- collections.OrderedDict(): python 3.6 이하에서 입력 순서가 유지되는 해시테이블
	- collections.Counter(): 요소의 값을 키로 하고 개수를 값 형태로 만들어 카운팅하는 객체
	- collections.defaultDict(int): 존재하지 않는 키를 조회할 경우, 에러 메세지를 출력하는 대신 디트 값을 기준으로 해당키에 대한 딕셔너리 아이템을 생성