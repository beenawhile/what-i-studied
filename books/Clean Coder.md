# 정리
## 1. 프로의 마음가짐
### **[ 함부로 바라지 마라 ]**

프로의 마음가짐, 프로페셔널리즘(Professionalism)이라는 용어에는 숨은 뜻이 있다. 그것은 명예와 긍징의 상징인 동시에 **책임과 의무** 나타내는 것이다.

프로가 아니라면 세상을 살기 편해진다. 하는 일에 책임을 느낄 필요가 없고, 회사에 책임을 떠넘겨도 되기 때문이다. 하지만 프로는 실수하면 스스로 뒷감당을 해야 한다.

### **[ 기능에 해를 끼치지 마라 ]**

**오류를 만들면 안된다.**

오류를 만들면 기능에 해가 된다. 따라서 프로가 되려면 오류를 만들면 안된다. 하지만 소프트웨어는 너무 복잡해서 오류가 생길 수 밖에 없다. 그렇다고 너무 복잡하다는 이유로 책임이 사라지지는 않는다.

그러므로 우리는 완벽하지 않다는 사실에 책임을 져야 한다. 완벽한 소프트웨어를 만드는 일이 사실상 불가능하다는 것이지 완벽하지 않아도 괜찮다는 것은 아니다. 그러므로 프로라면 오류에 책임을 져야 하며, 우선 사과하는 법을 익혀야 한다. 사과는 필수 요소지만 그것만으로는 충분하지 않다. 같은 오류를 반복하면 안되고, 경력을 쌓아가면서 오류를 만드는 비율을 0에 가깝게 떨어뜨릴 수 있어야 한다.

**QA는 아무것도 찾지 못해야 한다.**

소프트웨어를 출시할 때는 QA가 문제를 찾지 못할 것이라고 자신할 수 있어야 한다. 코드에 결함이 있는 것 알면서도 QA에게 코드를 보내는 것은 매우 프로답지 못하다. 여기서 결함이 있는 코드란 확신을 갖지 못하는 코드 전부를 의미한다.

하지만 우리가 놓친 오류들을 QA는 결국 찾을 것이다. QA가 문제를 찾을 때마다, 더 나쁜 경우 사용자가 문제를 찾을때 마다 놀라움과 분함을 느껴야 마당하며, 다시는 그런 일이 생기지 않도록 마음을 다져야 한다.

**제대로 작동하는지 아닌지 알아야 한다.**

코드가 잘 돌아가는지 아는 방법은 테스트하고 또 테스트하는 것이다. 하지만 테스트를 계속 하면 시간이 많이 걸리고 일정을 맞추지 못할 수 있다.

그러므로 우리는 테스트를 자동화해야 한다. 빠르게 실행가능한 테스트를 만들고 가능한 자주 돌려야 한다. 얼마만큼의 코드를 자동화한 단위 테스트를 작성해야 하느냐? 대답할 필요조차 없이 모조리 해야 한다.

100%의 테스트 커버리지를 권장하는게 아니고, 강력히 요구한다. 실행된다면 제대로 돌아가는지 알아야 하는데, 방법은 테스트 뿐이다.

만약 테스트가 어려운 코드가 있다면, 코드를 테스트하기 어렵게 설계했기 때문이다. 해결책은 테스트하기 쉽게 코드를 설계하는 것이고, 가장 좋은 방법은 테스트 코드를 먼저 작성하는 테스트 주도 개발(TDD, Test-Driven Development)로 개발하는 것이다.

### **[ 구조에 해를 끼치지 마라 ]**

전체 구조를 희생하면서까지 기능을 추가하는 일은 헛수고라는 것을 프로라면 당연히 알고 있다.

구조가 좋아야 코드가 유연해지는 것이며, 구조가 위태로우면 미래도 위태롭다.

소프트웨어는 변한다라는 생각은 모든 소프트웨어 프로젝트의 기본 가정이다. 이 가정을 어기고 구조를 유연하게 만들지 못하면 수익 기반인 경제 모델이 취약해진다.

즉, 변경을 할 때 터무니없는 비용을 치르지 않고 변경할 수 있어야 한다. 하지만 대부분의 프로젝트는 형편없는 구조 때문에 허덕이게 된다. 하루면 끝날 작업은 일주일이 걸리게 되고, 관리자들은 속도를 빠르게 하고자 개발자들을 더 고용한다. 하지만 이들 역시 곤란한 상황만 더하고 구조에 큰 피해를 입히며 장애물을 만들 뿐이다.

이러한 상황을 피하기 위해 우리는 모듈을 살펴볼 때 마다 작고 가벼운 변화를 더해 구조를 개선해야 한다. 코드를 읽을 때마다 구조를 바꿔야 한다.

누군가는 동작 중인 소프트웨어를 바꾸는 일이 위험하다고 생각한다. 하지만 이는 사실이 아니다. 코드를 바꾸는 것을 두려워하는 이유는 망가트릴까봐 이며, 이는 테스트가 없기 때문이다. 만약 자동화된 테스트 묶음(suite)의 커버리지가 100%이며, 재빨리 돌려볼 수 있다면 코드를 바꾸는 일은 전혀 무섭지 않다.

오히려 정말 위험한 일은 소프트웨어를 고장난 상태로 두는 것이다.

### **[ 전산 분야 지식을 익혀라 ]**

다음은 프로 소프트웨어 개발자라면 알아야 하는 최소한의 기술 목록이다.

-   디자인 패턴: 24가지 GOF 패턴을 설명할 수 있고, POSA 패턴을 실무에 적용할 수준으로 알아야 한다.
-   설계 원칙: SOLID 객체 지향 원칙을 알아야 하고, 컴포넌트 개념을 충분히 이해해야 한다.
-   방법론: XP, 스크럼, 린, 칸반, 폭포수, 구조적 분석, 구조적 설계 개념을 충분히 이해해야 한다.
-   원칙: 테스트 주도 개발, 객체지향 설계, 구조적 프로그래밍, 지속적 통합, 짝 프로그래밍을 실천해야 한다.
-   도구: UML, 데이터 흐름도, 구조 차트, 페트리 넷, 상태전이 다이어그램과 테이블, 흐름도, 결정 테이블을 어떻게 쓰는지 알아야 한다.

### **[ 끊임없이 배우기 ]**

**연습하기**

프로는 연습한다. 업종에 무관하게 진정한 프로는 기술을 날카롭게 갈고 닦아 항상 준비된 상태로 만들려고 애쓴다. 소프트웨어 개발자들은 프로그래밍을 통해 훈련을 계속해서 반복해야 한다. 간단한 알고리즘 문제를 푸는 형식도 괜찮다. 아침과 저녁에 짧은 시간 프로그래밍을 하는 것은 도움이 된다.

품새(Dojo, Kata)를 통해 훈련하듯, 손가락, 두뇌를 단련하기 위해 간단한 훈련을 반복해서 연습하자
ex) 볼링 점수 계산, 인수분해 등
단축키도 익숙해질 수 있음

**함께 일하기**

배움에 도움이 되는 또 다른 방법은 다른 사람들과 함께 일하는 것이다. 그러면 서로 많이 배울 뿐 아니라 일도 빨리 끝나고 오류가 더 적다.

**멘토링**

배우기에 가장 좋은 방법은 가르치는 것이다. 가르치고 배울 때 더 큰 이득을 보는 쪽은 가르치는 사람이다.

마찬가지로 새로운 사람을 조직에 익숙하게 만드는 가장 좋은 방법은 옆에서 작업 요령을 알려주는 것이다. 프로라면 후배들을 멘토링해야 하고, 방치된 채 이리저리 떠돌게 둬서는 안된다.

**겸손**

프로그래밍은 무에서 유를 창조하는 행위이다. 프로는 자신의 일을 이해하고, 그 일에 자부심을 가진다. 프로는 자기 능력을 확신하고, 그 확신을 바탕으로 위험을 과감히 짊어진다.

그러나 프로는 때때로 실패하고, 언젠가 자신의 능력이 부족해지는 날이 온다는 것을 안다. 그리고 프로는 자신이 웃음거리가 됐을 때 가장 먼저 웃어야 한다. 절대 다른 사람을 비웃지 않지만 자신이 비웃음거리가 될 만하다면 받아들여야 한다. 그렇다고 다른 사람은 당신이 실수를 했다고 망신을 주지 않을 것이다. 왜냐하면 다음 번 실패할 사람이 자신이 될 수 있기 때문이다.

프로는 목표가 무너졌을 때 웃고, 이를 받아들일 수 있어야 한다.

---
## 2. 아니라고 말하기
-   어떠한기능을 구현하기 위한 시간과 왜 그만큼의 시간이 필요한지, 담당자가 원하는 시간까지는 무리임을 명백하게 주장할 수 있어야 한다
-   안되는 것에 대한 말은 빠를수록 좋다
-   ‘노력’하겠다는 말을 하지 말 것, 그렇다면 이전까지는 노력 안했다는 말…?

---
## 3. 예라고 말하기
-   약속의 경우 다음과 같이 협동해야 한다
    -   하겠다고 말한다
    -   진심을 담는다
    -   실제로 실행한다
-   아래의 말은 약속의 문구가 아니다
    -   필요 / 해야한다
    -   희망/ 바람
    -   하자  —> ‘내가’ 라는 주체가 없기 때문에
-   약속은 자신이 모든 상황을 제어할 수 있을 때만 쓰여야 한다. 다른 사람의 의존이 불가피한 경우 목표달성을 위한 구체적인 약속을 해야한다
-   약속을 지키지 못하는 상황이 발생하면 경고하고 약속 문제를 빠르게, 즉시 말해야 한다

---
## 4. 코딩
### **[ 준비된 자세 ]**

코딩은 어려운데다 사람을 지치게 하는 지적 활동이다. 다른 훈련에서는 찾기 힘든 일정 수준의 농축된 집중력이 필요하다.

1.  코드는 반드시 동작해야 한다.
    
    1.  풀고자 하는 문제가 어떤 문제이고 어떻게 풀어야 하는지 확실히 이해해야 한다.
    2.  그리고 해결법을 나타낸 코드에 믿음이 가는지 확인해야 한다.
    
2.  코드는 고객이 제시한 문제를 반드시 풀어야 한다.
    
    1.  고객의 요구사항이 고객의 문제를 해결하는데 도움이 안되는 경우도 있다.
    2.  이런 상황을 파악하고 고객과 협상해 고객의 진정한 필요를 충족시키는 일은 본인에게 달려있다.
    
3.  코드는 기존 시스템에 잘 녹아들어야 한다.
    
    1.  기존 시스템의 경직성, 취약함, 불투명도를 높이면 안되고, 의존성도 잘 관리되어야 한다.
    2.  즉, 코드는 SOLID 객제지향 원칙을 따라야 한다.
    
4.  코드는 다른 프로그래머가 읽기 쉬어야 한다.
    
    1.  주석을 잘 쓰라는 단순한 조언이 아니다. 코드에는 작성자의 의도가 잘 드러나도록 다듬어야 한다.
    2.  이는 프로그래머가 통달하기 가장 어려운 일이다.
    

충분히 강하게 집중하지 못하면 잘못된 코드를 만들게 된다. 코드에 오류가 섞이고 구조는 엉뚱해지고, 이해하기 힘든 뒤얽힌 코드가 된다. 만약 지치거나 주의력이 흩어졌다면 코드를 만들지 말자. 결국 재작업이 필요할 것이다.

### **[ 새벽 3시에 짠 코드 ]**

지쳤을 때는 코드를 만들지 않는 것이 좋다. 그렇지 않으면 잘못된 설계 구조와 오류들로 나중에 고생하게 될 것이다.

### **[ 근심이 담긴 코드 ]**

외적인 근심이 있을 때 작성한 코드들은 모두 쓰레기다. 그럴 때는 코딩을 하는 대신 근심을 풀어야 한다.

물론 회사에서 이러한 부분을 용납하지 않을 수 있다. 그럴 때는 시간을 나누어 일정 시간에는 근심을 풀고, 남은 시간에는 업무를 해야 한다.

물론 가장 좋은 것은 개인적인 문제들은 개인 시간에 힘쓰는 것이다.

### **[ 몰입 영역 ]**

몰입으로 알려진 상태는 코딩을 하는 동안 빠져드는 고도로 집중하는 상태이다. 하지만 이러한 몰입 상태는 오히려 생산적이지 못하고, 지나치게 몰두한 나머지 이성적 판단을 못하게 된다.

### **[ 외부 방해 ]**

코딩을 하다가 다른사람이 질문을 하면 개발 흐름이 끊기게 된다. 이를 위해서는 짝 프로그래밍이나 TDD가 도움이 된다. 짝 프로그래밍은 내가 흐름을 놓쳐도 짝이 흐름을 가지고 있기 때문이며, TDD는 테스트를 통해 작업의 흐름을 유지할 수 있기 때문이다.

### **[ 디버깅 시간 ]**

디버깅 시간은 TDD 원칙을 받아들이면 엄청나게 단축할 수 있다.

TDD가 아닌 다른 효과적인 원칙을 받아들이건 디버깅 시간을 가능한 0에 가깝게 줄이는 것이 프로의 의무이다. 0은 명백히 불가능하겠지만 목표는 목표이다.

### **[ 속도 조절 ]**

소프트웨어 개발은 마라톤이지 단거리 질주가 아니다. 시작부터 있는 힘껏 달리는 것이 아니라 자원을 보존하고 속도를 조절해야 한다.

예를 들어 풀고 있는 문제를 다 못풀었다면 집에 못가는 것이 아니고 가야한다. 피곤하면 창의성과 총명함이 사라진다. 그 상태에서 문제를 풀려고 하는 것은 어떠한 도움도 되지 않는다.

### **[ 속도 조절 ]**

언젠가는 마감을 못 지키는 날이 온다. 일정 지연을 관리하는 요령은 이른 감지와 투명성이다. 일정을 지키지 못할 것 같으면 바로 관계자들에게 알려라.

그리고 마감을 지키라는 압박이 들어와도 동의하면 안된다.(물론 이는 일정에 대해 진지하게 고민했을 때의 이야기다.) 이는 잘못된 희망을 통해 재앙으로 가게 한다. 일정에 맞추는 방법은 범위를 줄이는 것 뿐이다.

---
## 5. 테스트 주도 개발
### **[ 배심원 등장 ]**

TDD에 대한 논쟁은 블로그나 기사를 통해 수년간 계속 되었지만, TDD는 결국 잘 돌아가고 있으며 이를 우리는 받아들여야 한다.

일방적으로 느껴질 수 있지만, 연구자료를 봤을 때 프로그래머는 TDD를 적용해야 한다고 생각한다.

프로라면 작성한 코드가 전부 문제가 없는지를 알아야 하고, 테스트가 없다면 전부 문제가 없는지 파악하기가 힘들다. 그리고 TDD를 사용하지 않는다면 높은 커버리지를 갖는 자동화된 단위 테스트를 만들기가 어렵다.

### **[ TDD의 3가지 법칙 ]**

1.  실패한 단위 테스트를 만들기 전에는 제품 코드를 만들지 않는다.
2.  컴파일이 안 되거나 실패한 단위 테스트가 있으면 더 이상의 단위 테스트를 만들지 않는다.
3.  실패한 단위 테스트를 통과하는 이상의 제품 코드는 만들지 않는다.

이 3 가지 법칙을 지키면 반복 주기는 대략 30초 길이를 유지한다. 처음에는 작은 단위 테스트를 만들면서 시작한다. 하지만 몇 초 지나지 않아 아직 만들지도 않은 클래스나 함수의 이름을 써야 하고, 그 때문에 컴파일조차 되지 않는다. 따라서 테스트가 컴파일 되도록 제품 코드를 만들어야 한다. 하지만 그 이상의 제품 코드를 만들면 안되므로, 새로운 단위 테스트를 만들어야 한다.

TDD는 이렇게 테스트를 조금 추가하고, 제품 코드를 조금 추가하는 주기를 반복한다.

### **[ 수많은 혜택 ]**

**확산**

TDD를 프로다운 규칙으로 받아들이면 테스트를 하루에 수 십개 이상 만들게 된다. 그리고 코드가 수정되거나 추가되면 작성한 테스트를 통해 제품에 대한 확신을 얻을 수 있다.

**결함 주입 비율**

TDD로 개발하면 코드 추가 시 새로운 결함을 만드는 비율인 결함 주입 비율이 매우 낮다. 이는 단발적인 효과가 아니다.

**용기**

나쁜 코드를 봐도 고치지 않는 이유는 망가뜨릴지도 모른다는 위험 때문이다. 수정하였다가 망가지면 자신이 감당해야 하기 대문이다.

하지만 TDD를 한다면 믿음직한 테스트 묶음(Suite)가 있기 때문에 변경에 대한 두려움이 사라진다. 이를 통해 깔끔한 코드를 작성해 이해하기 쉽고 확장하기 쉽게 만든다. 또한 코드가 단순해져 오류가 생길 가능성이 줄어든다.

**문서화**

단위 테스트는 코드로 만든 예제이며, 시스템을 어떻게 사용해야 하는지 알려준다. 즉, 단위 테스트는 문서이며 시스템의 가장 낮은 단계의 설계를 알려준다. 테스트는 저수준 단계에서 가장 훌륭한 문서의 형태이다.

**설계**

3가지 단계(테스트 코드 → 제품 코드 → 리팩토링)에 따라 테스트를 만들다 보면 딜레마에 빠진다. 어떤 코드를 만들어야 하는지 정확히 아는데도 불구하고, 법칙을 따르려다 보니 제품 코드가 없어 실패하는 단위 테스트가 필요하기 때문이다.

테스트 코드를 만들기 위해서는 코드의 의존 관계를 고립시켜야 한다는 어려움이 있다. 다른 함수를 호출하는 함수는 테스트하기 어려운 경우가 많다. 그러면 우리는 자연스럽게 고민을 하게 되고, 결과로 의존성이 낮은 좋은 설계로 이어지게 된다.

**프로다운 선택**

TDD는 여러 장점들을 가져다 주는 원칙으로 TDD를 사용하는 것은 매우 프로다운 선택이라는 것이다.

### **[ TDD와 관련없는 사실 ]**

TDD는 많은 장점이 있지만 종교나 마법이 아니다. TDD로 개발하여도 형편없는 코드가 나오기도 한다. 물론 이런 경우는 드물지만 없지는 않다. 프로 개발자라면 좋은 점보다 해로운 점이 많을 때 규칙을 따라서는 안된다.

---
## 6. 연습
-   코딩 도장 : 코딩을 무술 연마에 비유하여 쓰는 말. 함께 모여 연습하기도 하고 개인적으로 하기도 한다
    -   품새
        -   어떤 문제 풀이를 정교하게 짜모은 것
        -   풀이보다는 동작과 결정 내기리를 연습한다
        -   단축키, 코드 관용구를 익힐 수 있는 좋은 방법
    -   합 맞추기
        -   ‘핑퐁’ 이라고 하며 한 명이 단위 테스트를 개발하고 다른 한 명이 그 테스트를 통과하는 코드를 짠다
    -   대련
        -   두 명이 합을 맞추어 서로의 문제를 풀게 만드는 것과 비슷하다

---
## 7. 인수 테스트
-   불확실성의 원칙 : 서류와 실제 시스템의 동작은 항상 다르다는 원칙
-   불안한 추정, 때늦은 모호함
-   인수테스트 : 요구사항이 언제 완료되는지를 정의하기 위해 이해 당사자들과 프로그래머들이 힘을 모아 작성하는 테스트
    -   완료 = 모든 코드 작성의 완료 + 모든 테스트 통과의 완료를 의미
    -   목적은 ‘의사소통’ 에 있다
    -   비용이 비싸므로 항상 자동화 해야한다
    -   사업 분석가의 테스트 : 행복한 경로 & QA 의 테스트 : 좋지 않은 경로 & 경제조건, 예외사항 등을 테스트
    -   개발자는 인수테스트를 실행하고 오류를 확인하고 원하는 기능을 실행하여 테스트를 통과 시킨다
-   인수테스트 vs 단위테스트
    -   단위테스트 : 프로그래머 for 프로그래머
    -   인수테스트 : 사업적 관섬

                —> 같은 내용을 테스트 할지라도 다른 메커니즘과 경로를 통해서 테스트 한다

---
## 8. 테스트 전략
### **[ QA는 오류를 찾지 못해야 한다. ]**

회사에 소프트웨어를 테스트하는 QA팀이 있더라도, 개발팀은 QA가 문제를 찾지 못하는 상태를 목표로 삼아야 한다. 물론 마음먹었고 쉽게 달성할 수 있는 목표는 아니다.

아무리 작업을 하여도 QA는 문제를 찾을 것이고, QA가 문제를 발견할 때마다 개발팀은 간담이 서늘해져야 정상이다. 그리고 오류가 어떻게 발생했는지 파악하여 다시 발생하지 않도록 조치해야 한다.

QA는 같은 팀이며, QA와 개발자는 시스템 품질 향상을 위해 힘을 합쳐야 한다.

### **[ 테스트 자동화 피라미드 ]**

프로 개발자는 단위 테스트를 만들기 위해 테스트 주도 개발 원칙을 따라야 하며, QA가 오류를 찾지 못하리라는 확신을 가지려면 상위 계층 테스트 또한 필요하다. 테스트들은 다음과 같은 순서로 구성된다. 갈수록 더 상위 테스트에 해당된다.

1.  단위 테스트
2.  컴포넌트 테스트
3.  통합 테스트
4.  시스템 테스트
5.  탐색 테스트

**단위 테스트**

단위 테스트는 피라미드의 가장 아래 계층에 존재한다. 단위 테스트는 프로그래머에 의해 프로그래머를 위해 시스템 프로그래밍 언어로 만든 테스트이다. 단위 테스트는 시스템의 최하위 계층을 명세하는 의도로 만들어지며, 커버리지는 최대한 100에 가까워야 한다.

**컴포넌트 테스트**

컴포넌트 테스트는 인수 테스트의 일종으로, 보통 컴포넌트 테스트의 대상은 시스템의 독립 컴포넌트이다.

컴포넌트 테스트는 컴포넌트에 입력 값을 넣고 출력 값을 받아 모으고, 입력에 대한 출력이 올바른지 테스트한다. 테스트 대상이 아닌 컴포넌트는 적절한 mocking 또는 대역을 사용하여 테스트로부터 분리한다.

컴포넌트 테스트는 QA와 사업부가 개발팀의 도움을 받아 작성하며 시스템의 절반 정도를 감당한다.

**통합 테스트**

통합 테스트는 여러 컴포넌트로 이루어진 큰 시스템에만 의미가 있다. 통합 테스트는 컴포넌트 묶음을 모아서 묶음끼리 제대로 상호작용하는지 테스트한다. 테스트 대상이 아닌 컴포넌트는 적절한 mocking 또는 대역을 사용하여 테스트로부터 분리한다.

통합 테스트는 대개 시스템 아키텍트나 수석 설계자가 만들며, 성능 테스트나 처리량 테스트가 진행되기도 한다. 통합 테스트는 시간이 많이 들기 때문에 지속적 통합때는 수행하지 않으며, 주기적으로 필요할 때마다 돌린다.

**시스템 테스트**

시스템 테스트는 통합한 시스템 전체를 대상으로 하는 자동화 테스트이다. 즉, 궁극적인 통합 테스트이다. 시스템이 올바르게 연결 되었고, 각 부분이 계획에 따라 상호작용하는지 테스트한다. 보통 성능이나 처리량 테스트는 시스템 테스트 단계에서 실행된다.

시스템 테스트는 시스템 아키텍트나 기술 책임자가 만들며, 실행 속도에 비해 자주 돌리는 편이지만 자주 돌리면 좋다.

시스템 테스트는 대략 시스템의 10%를 감당한다. 시스템이 올바르게 동작하는지보다 시스템을 올바르게 빌드했는지를 확실히하려는 목적이기 때문이다.

**수동 탐색 테스트**

수동 탐색 테스트는 키보드에 손을 얹고 모니터를 보며 직접 하는 테스트이다. 자동화된 테스트가 아니며, 스크립트로된 테스트도 아니다. 이 테스트의 목적은 시스템이 기대한 대로 동작하는지 확인하고, 예상치 못한 오류를 찾아내는 것이다. 목표 달성을 위해서는 인간의 두뇌와 창의력이 필요하다.

어떤 팀은 모든 관계자를 불러 시스템을 마구 두드려 보라고도 한다. 수동 탐색 테스트의 목적은 커버리지가 아니고, 모든 실행 경로를 빠짐없이 검사하여 가능한 많은 특이사항을 창의적으로 발견하는 것이기 때문이다.

---
## 9. 시간 관리
-   회의 : 당장의 이익이나 큰 이득이 있는 경우에만 참석할 것
    -   거부할 때는 정중히 거절하도록 한다
    -   빠져나올 때는 주제가 잘못된 길로 갈 때 진행순서를 바꾸거나 신속히 진행하거나 또는 현재 중요도에 따라서 빠져나올 줄 알아야한다
    -   의제와 목표를 정하고 해당 주제로만 회의한다
    -   일일회의 : 어제 한 것 + 오늘 할 것 + 방해요소 유무에 대하여 1분 정도로 이야기 한다
    -   반복 계획 회의 : 제품 백로그 ~ 다음 반복 주기 동안 처리할 항목을 고르기 위한 회의. 각 항목은 5~10분 정도 소요한다
    -   반복회고와 시연 : 회고 20분, 시연 25분
    -   논쟁 / 의견 차이 : 5분 내로 해결하도록 한다. 데이터가 꼭 필요하다. 총 50분. 팀원 간 의견을 발표한다.
-   집중력 마나 : 수면, 카페인, 재충전, 근육 집중 등
-   타입박스와 토마토 : 포모도로 기법 =(25분 타이머 + 5분 휴식 (전화, 그 외 업무 처리))* 4번 + 30분 휴식 하기
-   우선순위를 지키고 피하지 말 것
-   막다른 길을 빠르게 돌아올 것
-   선택지를 넓힐 것

---
## 10. 추정
-   약속과 추정은 다르다
    -   약속 : 꼭 지켜야하는 것 
    -   추정 : 약속x , 추정은 어림짐작이다. 약속에 포함되지 않는다
        -   방법 : PERT
            -   프로그램 평가와 검토 기술
            -   미해군이 폴라리스 잠수함 프로젝트를 지원하기 위해 만들었다
        -   추정에 사용하는 자원 중 가장 중요한 자원은 주변사람들이다
    -   사업부는 추정을 약속으로 보고 개발자는 추정을 어림짐작으로 본다
-   업무를 추정할 때 세 가지 숫자를 제시한다. 이 숫자를 3방 분석이라한다
    -   O 낙관적 추정 값
    -   N 명목 추정 값
    -   P 비관적 추정 값
-   광역적 델파이 : 의결일치. 사람을 모아 팀을 꾸리고, 토론하고, 추정하고, 합의에 도달할 때까지 토론과 추정을 반복한다
    -   날아다니는 손가락
        -   한번에 하나의 업무에 대해서 토론
        -   손가락으로 0-5 의 숫자로 얼마나 걸릴지 생각해서 표현한다
        -   모든 의견이 일치하면 다음으로 넘어가고 아니라면 일치할 때 까지 계속한다
    -   계확포커
        -   숫자를 적힌 카드를 사용한다. 날아다니는 손가락과 유사하다
    -   관계추정
        -   모든 업무를 카드에 적고 추정값을 적지 않는다
        -   업무카드를 상대적으로 비교하여 긴 시간이 필요한 업무를 오른쪽, 짧은 시간은 왼쪽으로 옮긴다
-   큰 수의 법칙
    -   큰 업무를 여러 개의 작은 업무로 쪼개 따로따로 추정하면, 하나의 큰 업무 추정 값보다 작은 업무들의 추정 값의 합이 정확하다.
-   개발자는 사업부가 계획을 짜는데 쓰도록 실용적인 추정값을 전달해야 한다

---
## 11. 압박
-   달성할 확신이 없는 마감일의 약속은 피해야 한다
-   빠르고 지저분하게 라는 말은 모순이다. 어떤 때라도 지저분함은 느리다는 의미이다. 언제나 깔끔한 상태를 유지하자
-   TDD, 유닛테스트와 같은 규율을 지켜야 한다
-   당황하지 말것
-   팀에게 압박, 어려움의 상황을 알리고 도움을 받아야 한다

---
## 12. 함께 일하기 
-   소프트웨어는 팀원들이 프로답게 힘을 모을 때 가장 효율적이다
-   프로그래머의 업무는 사업이 순조롭게 나아가도록 만드는 일이다
-   코드는 공동 소유로 가져가고 다른 사람의 코드 작업을 막지 않아야 한다
-   짝 프로그래밍을 하자

---
## 13. 팀과 프로젝트
-   팀에게 프로젝트를 부여하는 것이 프로젝트를 위해 팀을 생성하는 것 보다 낫다
-   팀은 프로젝트보다 만들기 더 어렵다 
-   영구적인 팀을 만들고 여러 프로젝트를 할당시키는 편이 더 좋다

---
## 14. 스승과 제자 그리고 장인정신
-   수습기간 : 인턴은 스승과 함께 한다
-   장인들 : 10년 이상의 경력. 여러 다른 시스템과 언어를 사용해본 사람
-   숙련공 : 능숙하고 훈련받은, 열정적인 프로그래머. 경력 5년 정도의 개발자
-   견습생 / 인턴 : 대학 졸업생, 자주성이 없으며 숙련공들의 밀착 지도를 받고 일을 돕는다. 짝 프로그래밍을 한다
-   장인 = 서두르지 않으면서도 일을 빠르게 처리하며 합리적인 평가를 제공하고 임무를 처리하는 사람
-   장인정신 = 장신 정신은 장인들이 지니고 있는 사고방식으로 가치, 규율, 기술, 자세 및 답변을 포함하는 밈

---


